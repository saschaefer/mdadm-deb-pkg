#!/bin/sh
#
# checkarray -- initiates a check run of an MD array's redundancy information.
#
# Copyright © martin f. krafft <madduck@debian.org>
# distributed under the terms of the Artistic Licence 2.0
#

#NOTE 1
# The check is needed for a simple reason: this script does 2 check in a row (so very quickly)
# on the same array, the first one to get the array size [TODO we really need another way to get it]
# and the second one is the real check. The kernel might be too slow to "reset" the situation after
# the first check and when the script echo check the second time it fails with return code 1
# (resource busy in this case). Now why reading sync_action prevent this? couse the kernel does an
# atomic write on it, so the file is locked even for reading, and the script will be able to read it
# only when the kernel "reset" after the array is cleared and ready for another check.
# Of couse *this is just my hypothesis* but that's the only explanation i've found

set -eu

PROGNAME=${0##*/}
CANCEL_FILE=/var/lib/mdadm/cancelled

about()
{
  echo "$PROGNAME -- MD array (RAID) redundancy checker tool"
  echo "Copyright © martin f. krafft <madduck@debian.org>"
  echo "Released under the terms of the Artistic Licence 2.0"
}

usage()
{
  about
  echo
  echo "Usage: $PROGNAME [options] [arrays]"
  echo
  echo "Valid options are:"
  cat <<-_eof | column -s\& -t
	-a|--all & check all assembled arrays (check /proc/mdstat).
	-s|--status & print redundancy check status of devices.
	-x|--cancel & queue a request to cancel a running redundancy check.
	-i|--idle & perform check in a lowest I/O scheduling class (idle).
	-l|--slow & perform check in a lower-than-standard I/O scheduling class.
	-f|--fast & perform check in higher-than-standard I/O scheduling class.
	--realtime & perform check in real-time I/O scheduling class (DANGEROUS!).
	-c|--cron & honour AUTOCHECK and CHECK_SPLIT setting in /etc/default/mdadm.
	-S|--split <int arg> & 0 to avoid split, otherwise check arg/28 of the array starting from the last checked sector
	-q|--quiet & suppress informational messages.
	-Q|--real-quiet & suppress all output messages, including warnings and errors.
	-W|--wait & will not exit until the check is done
	-h|--help & show this output.
	-V|--version & show version information.
	_eof
  echo
  echo "Examples:"
  echo "  $PROGNAME --all --idle"
  echo "  $PROGNAME --quiet /dev/md[123]"
  echo "  $PROGNAME -sa"
  echo "  $PROGNAME -x --all"
  echo
  echo "Devices can be specified in almost any format. The following are"
  echo "all equivalent:"
  echo "  /dev/md0, md0, /dev/md/0, /sys/block/md0"
  echo
  echo "The --all option overrides all arrays passed to the script."
  echo
  echo "You can also control the status of a check with /proc/mdstat ."
}

# write info to stderr, $1 is the info type (I for info, W for warnings, E for errors and so on),
# all following argument will be printed to stderr
wlog() {
  local ltype=$1
  local logstring="$PROGNAME: $ltype:"
  shift
  logstring="$logstring $@"
  case "$quiet/$ltype" in
    0/*|*/[WE]) echo "$logstring" >&2;;
  esac
  # TODO add a call to logger if --cron is used?
}

# a general function to set sync_{action,min,max}
# $1 is when the action should be done, $2 what we should echo to sync_action, $3 sync_min $4 sync_max $5 $array
# $1 can be "before" and sync_action will be set before min and max or "after" and action will be set after
# if you don't want to set the action just use "never" as the first argument
setup_array() {
  if [ "$1" = before ] ; then 
    echo $2 > /sys/block/$5/md/sync_action || return 7
  fi
  # WARNING don't remove this check, see NOTE 1 at the beginning of the file
  [ $(cat /sys/block/$5/md/sync_action) != idle ] && return 6
  echo $3 > /sys/block/$5/md/sync_min || return 3
  echo $4 > /sys/block/$5/md/sync_max || return 4
  if [ "$1" = after ] ; then
    echo $2 > /sys/block/$5/md/sync_action || return 5 #it fails here without the previous cat
  fi
  # we might add a sleep or inotifywait here instead of using that cat???
  return 0
}

# set the array as idle and restore sync_{min,max} to default value. $1 is $array
alias cleanup_array='setup_array before idle 0 max'

# start an array check, $1 is sync_min, $2 sync_max, $3 $array
alias start_check='setup_array after check'

# this must be called if check is splitted because when syc_max is not equal to 'max' the check will just
# pause, waiting for sync_max to be rised and sync_action is not restored to idle
# it also stores the last checked sector for the next split
# $1 must be $array, $2 $next_last_sector, $3 $save_file 
wait_completed() {
  # this must be zero by default since even if sync_min is > 0 if the check is queued
  # but still not started zero will be set in sync_completed
  local prev_last_checked=0
  sleep 3
  local last_checked=$(cut -d ' ' -f1 /sys/block/$1/md/sync_completed)
  # the first one checks if sync_completed is 'none', in case $last_sector is equal to $asize
  # because sync_action is set to 'idle' automatically in this situation
  # the second condition checks if the last sector checked is equal to $last_sector
  while [ "$last_checked" != "none" -a "$last_checked" != "$2" ] ; do
      sleep 3
      # inotifywait might be used here instead of sleep with something like
      # inotifywait -q -e modify /sys/block/$1/md/sync_completed | :
      # the | : is necessary couse (according to man inotifywait) it returns 1 when success... not tested myself

      # save this if the check has been cancelled
      prev_last_checked=$last_checked
      last_checked=$(cut -d ' ' -f1 /sys/block/$1/md/sync_completed)
  done
  [ "$last_checked" = "none" ] && last_checked=$prev_last_checked
  # if the check has been cancelled echo last_checked sector otherwise next_last_sector
  if [ -e $CANCEL_FILE.$1 ] ; then
    # echo this only if we have actually checked something
    [ "$prev_last_checked" != "0" ] && echo $last_checked > $3
    rm -rf $CANCEL_FILE.$1
  else
    echo $2 > $3
  fi
  cleanup_array $1 || { EXIT=$? ; wlog E "cleanup of array $1 FAILED. Error code: $EXIT" ; return $EXIT ; }
  wlog I "check for array $array terminated"
  return 0
}

# start a fake check and reads sync_completed to get the array size 
# (not equal to arraysize reported in mdstats and in mdadm -D
# $1 is $array, $2 $chunk_size
# TODO pls find or implement in md-mod a better way to get this
get_size() {
  start_check 0 $2 $1 || return $?
  local a_size=$(cut -d ' ' -f3 /sys/block/$1/md/sync_completed) || return 10
  cleanup_array $1 || return $?
  echo $a_size
  return 0
}

SHORTOPTS=achVqQsxilfS:W
LONGOPTS=all,cron,help,version,quiet,real-quiet,status,cancel,idle,slow,fast,realtime,split:,wait

GETOPTTMP=$(getopt -o $SHORTOPTS -l $LONGOPTS -n $PROGNAME -- "$@") || { usage >&2; exit 1; }
eval set -- "$GETOPTTMP"

arrays=''
cron=0
all=0
quiet=0
status=0
action=check
ionice=idle
split=-1
shouldwait=0
waitpid=

while true ; do
  case "$1" in
    -a|--all) all=1 ; shift;;
    -s|--status) action=status ; shift;;
    -x|--cancel) action=idle ; shift;;
    -i|--idle) ionice=idle ; shift;;
    -l|--slow) ionice=low ; shift;;
    -f|--fast) ionice=high ; shift;;
    --realtime) ionice=realtime ; shift;;
    -c|--cron) cron=1 ; split=0 ; shift;;
    -S|--split) split=$2 ; shift 2;;
    -q|--quiet) quiet=1 ; shift;;
    -Q|--real-quiet) quiet=2 ; shift;;
    -W|--wait) shouldwait=1 ; shift;;
    -h|--help) usage; exit 0;;
    -V|--version) about; exit 0;;
    --) shift ; break;;
    *) wlog E "invalid option: $1" >&2; usage >&2; exit 1;;
  esac
done

for opt in $@ ; do
  case "$opt" in
    /dev/md/*|md/*) arrays="${arrays:+$arrays }md${opt#*md/}";;
    /dev/md*|md*) arrays="${arrays:+$arrays }${opt#/dev/}";;
    /sys/block/md*) arrays="${arrays:+$arrays }${opt#/sys/block/}";;
    *) wlog E "invalid option: $opt" >&2; usage >&2; exit 1;;
  esac
done

is_true()
{
  case "${1:-}" in
    [Yy]es|[Yy]|1|[Tt]rue|[Tt]) return 0;;
    *) return 1;
  esac
}

DEBIANCONFIG=/etc/default/mdadm
[ -r $DEBIANCONFIG ] && . $DEBIANCONFIG
if [ $cron = 1 ] && ! is_true ${AUTOCHECK:-false}; then
  [ $quiet -lt 1 ] && echo "$PROGNAME: I: disabled in $DEBIANCONFIG ." >&2
  exit 0
fi

if [ ! -f /proc/mdstat ]; then
  [ $quiet -lt 2 ] && echo "$PROGNAME: E: MD subsystem not loaded, or /proc unavailable." >&2
  exit 2
fi

if [ ! -d /sys/block ]; then
  [ $quiet -lt 2 ] && echo "$PROGNAME: E: /sys filesystem not available." >&2
  exit 7
fi

if [ -z "$(ls /sys/block/md* 2>/dev/null)" ]; then
  if [ $quiet -lt 2 ] && [ $cron != 1 ]; then
    echo "$PROGNAME: W: no active MD arrays found." >&2
    echo "$PROGNAME: W: (maybe uninstall the mdadm package?)" >&2
  fi
  exit 0
fi

if [ -z "$(ls /sys/block/md*/md/level 2>/dev/null)" ]; then
  [ $quiet -lt 2 ] && echo "$PROGNAME: E: kernel too old, no support for redundancy checks." >&2
  exit 6
fi

if ! egrep -q '^raid([1456]|10)$' /sys/block/md*/md/level 2>/dev/null; then
  [ $quiet -lt 1 ] && echo "$PROGNAME: I: no redundant arrays present; skipping checks..." >&2
  exit 0
fi

if [ -z "$(ls /sys/block/md*/md/sync_action 2>/dev/null)" ]; then
  [ $quiet -lt 2 ] && echo "$PROGNAME: E: no kernel support for redundancy checks." >&2
  exit 3
fi

[ $all = 1 ] && arrays="$(ls -d1 /sys/block/md* | cut -d/ -f4)"

for array in $arrays; do
  SYNC_ACTION_CTL=/sys/block/$array/md/sync_action

  if [ ! -e $SYNC_ACTION_CTL ]; then
    [ $quiet -lt 1 ] && echo "$PROGNAME: I: skipping non-redundant array $array." >&2
    continue
  fi

  cur_status="$(cat $SYNC_ACTION_CTL)"

  if [ $action = status ]; then
    echo "$array: $cur_status"
    continue
  fi

  if [ ! -w $SYNC_ACTION_CTL ]; then
    [ $quiet -lt 2 ] && echo "$PROGNAME: E: $SYNC_ACTION_CTL not writeable." >&2
    exit 4
  fi

  if [ "$(cat /sys/block/$array/md/array_state)" = 'read-auto' ]; then
    echo "$PROGNAME: W: array $array in auto-read-only state, skipping..." >&2
    continue
  fi

  case "$action" in
    idle)
      # we must remeber the check was cancelled for wait_completed
      # WARNING there is a race condition here if wait_completed is still active
      # but doesn't harm so much since in the worst case some sector will be checked twice
      # in a row, TODO some fix? Using inotifywait in wait_completed doesn't solve
      # the race condition, but it will happen rarely
      touch $CANCEL_FILE.$array || :  # TODO how to handle this error ?
      cleanup_array $array
      [ $quiet -lt 1 ] && echo "$PROGNAME: I: cancel request queued for array $array." >&2
      ;;

    check)
      if [ "$cur_status" != idle ]; then
        [ $quiet -lt 2 ] && echo "$PROGNAME: W: array $array not idle, skipping..." >&2
        continue
      fi
      # we don't need this anymore
      [ -e $CANCEL_FILE.$array ] && rm -rf $CANCEL_FILE.$array
      # this is the file where we save/read the last checked sector from the last run
      save_file=/var/lib/mdadm/last_sector.$array

      chunk_size=$(cat /sys/block/$array/md/chunk_size)
      # chunk_size is given in byte, not in sectors, convert it
      # a sector is 512 byte normally
      chunk_size=$(($chunk_size/512))
      # not all raid level has chunk_size (for example raid 1), if so set it to 1
      [ $chunk_size -lt 1 ] && chunk_size=1
      # get the array size
      #asize=$(mdadm -D /dev/$array | awk '/Array Size : / { print $4 }') # this is not the size we want
      asize=$(get_size $array $chunk_size) || { wlog E "error getting array size for array $array. Error code: $?"; continue; }
      last_sector=0
      next_last_sector=$asize
      # if split is:
      # 0 no split at all
      # -1 the default setting in $DEBIANCONFIG will be used couse the user didn't specified the -S/--split option
      # [0-9]* will be used
      case "$split" in
        -1) if [ -z ${CHECK_SPLIT?$(wlog E "no default option for split in $DEBIANCONFIG")} ] 2>/dev/null ; then
	      wlog E "no default option for split in $DEBIANCONFIG"
              exit 1
            fi ;;
        0) CHECK_SPLIT=-1 ;; 
        [0-9]*) CHECK_SPLIT=$split ;;
        *) wlog E "wrong argument for split option: $split"
           exit 1 ;;
      esac

      if [ $CHECK_SPLIT -ge 1 ] ; then
        # let's split the check
        [ $CHECK_SPLIT -gt 28 ] && CHECK_SPLIT=28
        # now calculate how much sectors should be checked (asize / CHECK_SPLIT)
        check_size=$(($asize/$CHECK_SPLIT))
        # $save_file must have +rw perms
        if [ -r $save_file -a -w $save_file ] ; then
          last_sector=$(cat $save_file)
        elif echo 0 > "$save_file" ; then
          #this is likely the first run, so we begin from zero
          last_sector=0
        else
          wlog E "$save_file has wrong perms or it cannot be created"
          continue
        fi
        [ $last_sector -lt 0 -o $last_sector -ge $asize -o -z "$last_sector" ] && last_sector=0
        # be pedantic, check that last_sector is a chunk_size multiple
        last_sector=$(($last_sector-$last_sector%$chunk_size))
        next_last_sector=$(($last_sector+$check_size))
        # we must round next_last_sector to a multiple of the chunk_size
        next_last_sector=$(($next_last_sector+$chunk_size-$next_last_sector%$chunk_size))
        [ $next_last_sector -gt $asize ] && next_last_sector=$asize
      fi

      # queue request for the array. The kernel will make sure that these requests
      # are properly queued so as to not kill one of the array.
      wlog I "check queued for array $array, from sector $last_sector to $next_last_sector"

      if ! start_check $last_sector $next_last_sector $array ; then
        wlog E "an error has occurred while trying to set up check for array $array. Error code: $?"
        cleanup_array $array || exit $?
        exit 13 # shame on md-mod ;)
      fi

      case "$ionice" in
        idle) arg='-c3';;
        low) arg='-c2 -n7';;
        high) arg='-c2 -n0';;
        realtime) arg='-c1 -n4';;
        *) break;;
      esac

      resync_pid= wait=5
      while [ $wait -gt 0 ]; do
        wait=$((wait - 1))
        resync_pid=$(ps -ef | awk -v dev=$array 'BEGIN { pattern = "^\\[" dev "_resync]$" } $8 ~ pattern { print $2 }')
        if [ -n "$resync_pid" ]; then
          if [ $cron != 1 ]; then
            echo "$PROGNAME: I: selecting $ionice I/O scheduling class for resync of $array." >&2
          fi
          ionice -p "$resync_pid" $arg
          break
        fi
        sleep 1
      done
      wait_completed $array $next_last_sector $save_file &
      waitpid="$waitpid $!"
      ;;
  esac
done

[ $shouldwait -ne 0 ] && { wait $waitpid || exit $? ; }
exit 0

